<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>doauth demo</title>
    </head>
    <body>
        <script>
            window.sodium = {
                onload: (sodium) => {
                    maybePort = () => {
                        if(window.location.port) {
                            return ':' + window.location.port
                        } else {
                            return ''
                        }
                    }
                    window.doAuth = {
                        server: window.location.protocol + '//' + window.location.hostname + maybePort(),
                        tofuPath: "/chappy/tofu",
                        saltSize: 16,
                        hashSize: 32,
                        keySize: 32,
                        defaultParams: {
                            opsLimit: sodium.crypto_pwhash_OPSLIMIT_SENSITIVE,
                            memLimit: 5 * sodium.crypto_pwhash_MEMLIMIT_MIN
                        },
                    }

                    window.doAuth.crypto = {}

                    window.doAuth.crypto.show = (bs) => {
                        return sodium.to_base64(bs, sodium.base64_variants["URLSAFE"])
                    }

                    window.doAuth.crypto.read = (s) => {
                        return sodium.from_base64(s, sodium.base64_variants["URLSAFE"])
                    }

                    window.doAuth.crypto.mainKey = (pass) => {
                        slipMaybe = localStorage.getItem("slip")
                        dp = doAuth.defaultParams
                        if(slipMaybe) {
                            return doAuth.crypto.mainKeyReproduce2(pass, JSON.parse(slipMaybe))
                        } else {
                            [mkey, slip] = doAuth.crypto.mainKeyInit2(pass, {
                                ops: dp.opsLimit,
                                mem: dp.memLimit,
                                saltSize: doAuth.saltSize,
                            })
                            localStorage.setItem("slip", JSON.stringify(slip))
                            return mkey
                        }
                    }

                    window.doAuth.crypto.mainKeyInit2 = (pass, slipConfig) => {
                        slip1 = {...slipConfig, salt: doAuth.crypto.show(sodium.randombytes_buf(slipConfig.saltSize))}
                        mkey = doAuth.crypto.mainKeyReproduce2(pass, slip1)
                        return [mkey, slip1]
                    }

                    window.doAuth.crypto.mainKeyReproduce2 = (pass, slip) => {
                        let {ops, mem, saltSize, salt} = slip
                        mkey = sodium.crypto_pwhash(
                            doAuth.hashSize, // kinda hardcoded but ok
                            pass,
                            doAuth.crypto.read(salt),
                            ops,
                            mem,
                            sodium.crypto_pwhash_ALG_DEFAULT
                        )
                        return mkey
                    }

                    window.doAuth.crypto.deriveSigningKeypair = (mkey, n) => {
                        mkd = sodium.crypto_kdf_derive_from_key(doAuth.keySize, n, "signsign", mkey)
                        let {publicKey, privateKey} = sodium.crypto_sign_seed_keypair(mkd)
                        return {public: publicKey, secret: privateKey}
                    }

                    window.doAuth.crypto.sign = (msg, {secret, public}) => {
                        return {public: public, signature: sodium.crypto_sign_detached(msg, secret)}
                    }

                    window.doAuth.crypto.verify = (msg, {public, signature}) => {
                        console.log(public, signature)
                        return sodium.crypto_sign_verify_detached(signature, msg, public)
                    }

                    window.doAuth.crypto.bland_hash = (msg) => {
                        return doAuth.crypto.show(sodium.crypto_generichash(doAuth.hashSize, msg))
                    }

                    /*
                     * TODO:
                     * console.log's are left in to show what the author
                     * checked. They are NOT A SUFFICIENT EVIDENCE that this
                     * function does what it's supposed to do and proper
                     * invariant testing and audit are absolutely necessary to
                     * run it in production.
                     */
                    function _canonicalise(x) {
                        // console.log("Canonicalising ", x)
                        if (typeof(x) === "string" || typeof(x) === "number" || typeof(x) === "bigint") {
                            // console.log("It's just a value", x)
                            return x
                        } else if (typeof(x) === "object") {
                            if (Array.isArray(x) === true) {
                                return x.map(x => _canonicalise(x))
                            } else {
                                var ks = Object.keys(x)
                                const x1 = {...x}
                                ks.sort()
                                var y = new Array()
                                for(let i = 0; i < ks.length; i++) {
                                    // console.log("Got object, working on adding **", ks[i], "**, the", i, "th element of", ks)
                                    y.push([ks[i], _canonicalise(x1[ks[i]], y)])
                                    // console.log("Accumulator so far:", [...y])
                                }
                                return y
                            }
                        }
                    }

                    window.doAuth.crypto.canonicalise = _canonicalise

                    window.doAuth.api = {}

                    window.doAuth.api.tofu = (x) => {
                        return fetch(x)
                            .then(resp => resp.json())
                    }

                    window.doAuth.credential = {}

                    window.doAuth.credential.proofless = (cred) => {
                        ctxs = cred['@context']
                        let {type, issuer, issuanceDate, credentialSubject} = cred
                        return {'@context': ctxs, type: type, issuer: issuer, issuanceDate: issuanceDate, credentialSubject: credentialSubject}
                    }

                    window.doAuth.credential.prooflessJSON = (cred) => {
                        return JSON.stringify(
                            doAuth.crypto.canonicalise(
                                doAuth.credential.proofless(cred)
                            )
                        )
                    }

                    window.doAuth.credential.verify = (cred, pk) => {
                        return doAuth.crypto.verify(
                            doAuth.credential.prooflessJSON(cred),
                            {
                                public: pk,
                                signature: doAuth.crypto.read(cred.proof.signature)
                            }
                        )
                    }

                    window.doAuth.credential.verify64 = (cred, pk) => {
                        return doAuth.credential.verify(cred, doAuth.crypto.read(pk))
                    }

                    window.doAuth.credential.txFromKeypairCredential = (kp, claim) => {
                        did = doAuth.did.fromPk(kp.public)
                        tau0 = util.iso8601WithoutMSec(new Date(Date.now()))
                        entity = did
                        proofless = {
                            '@context': [],
                            type: [],
                            issuer: entity,
                            issuanceDate: tau0,
                            credentialSubject: claim
                        }
                        sig = doAuth.crypto.sign(
                            JSON.stringify(
                                doAuth.crypto.canonicalise(proofless)
                            ), kp
                        )
                        proof = {
                            created: tau0,
                            proofPurpose: "assertionMethod",
                            signature: doAuth.crypto.show(sig.signature),
                            type: "libsodium2021",
                            verificationMethod: did
                        }
                        proofless.proof = proof
                        return proofless
                    }

                    window.doAuth.did = {}

                    window.doAuth.did.fromPk64 = (pk64) => "did:doma:" + doAuth.crypto.bland_hash(pk64)

                    window.doAuth.did.fromPk = (pk) => doAuth.did.fromPk64(doAuth.crypto.show(pk))

                    window.util = {}

                    window.util.iso8601WithoutMSec = (tau) => tau.toISOString().slice(0, -5) + "Z"

                    window.util.prettyPrint = (x) => JSON.stringify(x, null, 2)

                    window.wallet = {}

                    window.wallet.setupCallbacksDo = () => {
                        const qs = (path, phi) => {
                            input = document.querySelectorAll(path + " .input")
                            output = document.querySelectorAll(path + " .output")
                            if (!(input.length === 1 && output.length === 1)) {
                                throw("Expected to find exactly one input and output classes for path '" + path + "'")
                            }
                            [...input[0].children].map(x => {
                                if (x.type === "submit") {
                                    x.addEventListener("click", phi(input[0], output[0]))
                                }
                            })
                        }

                        qs(".crypto .mainKeyInit", (input, output) => () => {
                            if (localStorage.getItem("slip")) {
                                return output.textContent = util.prettyPrint({error: "slip is already stored in the localStorage"})
                            }
                            pass = input.querySelectorAll(".password")[0].value
                            mkey = doAuth.crypto.mainKey(pass)
                            doAuth.state.mkey = mkey
                            slip = localStorage.getItem("slip")
                            output.textContent = util.prettyPrint({mkey: doAuth.crypto.show(mkey), slip: JSON.parse(slip)})
                        })

                        qs(".crypto .withLocalStorageMainKeyReproduce", (input, output) => () => {
                            if (!(localStorage.getItem("slip"))) {
                                return output.textContent = util.prettyPrint({error: "slip is not stored in the localStorage"})
                            }
                            pass = input.querySelectorAll(".password")[0].value
                            mkey = doAuth.crypto.mainKey(pass)
                            doAuth.state.mkey = mkey
                            slip = localStorage.getItem("slip")
                            output.textContent = util.prettyPrint({mkey: doAuth.crypto.show(mkey), slip: JSON.parse(slip)})
                        })

                        qs(".crypto .mainKeyReproduce", (input, output) => () => {
                            pass = input.querySelectorAll(".password")[0].value
                            mkey = doAuth.crypto.mainKey(pass)
                            slipTxt = input.querySelectorAll(".slip")[0].value
                            console.log(slipTxt)
                            slip = JSON.parse(slipTxt)
                            mkey = doAuth.crypto.mainKeyReproduce2(pass, slip)
                            doAuth.state.mkey = mkey
                            output.textContent = util.prettyPrint({mkey: doAuth.crypto.show(mkey), slip: slip})
                        })

                        qs(".crypto .deriveSigningKeypair", (input, output) => () => {
                            mkey = doAuth.state.mkey
                            if (!mkey) {
                                return output.textContent = util.prettyPrint({error: "mkey is not loaded in doAuth.state.mkey; generate main key first"})
                            }
                            idTxt = input.querySelectorAll(".index")[0].value
                            if (!idTxt) {
                                return output.textContent = util.prettyPrint({error: "index must be set"})
                            }
                            id = JSON.parse(idTxt)
                            if (!(typeof(id) === "number" && id > 0)) {
                                return output.textContent = util.prettyPrint({error: "index must be a non-negative integer"})
                            }
                            kp = doAuth.crypto.deriveSigningKeypair(mkey, id)
                            doAuth.state.kp = kp
                            output.textContent = util.prettyPrint({public: doAuth.crypto.show(kp.public), secret: doAuth.crypto.show(kp.secret)})
                        })

                        qs(".credential .txFromKeypairCredential", (input, output) => () => {
                            kp = doAuth.state.kp
                            if (!kp) {
                                return output.textContent = util.prettyPrint({error: "kp is not loaded in doAuth.state.kp; generate main key and derive signing keypair first"})
                            }
                            claimTxt = input.querySelectorAll(".claim")[0].value
                            console.log(">" + claimTxt + "<")
                            claim = JSON.parse(claimTxt)
                            console.log(
                                "wtf"
                            )
                            cred = doAuth.credential.txFromKeypairCredential(kp, JSON.parse(claimTxt))
                            output.textContent = util.prettyPrint(cred)
                        })

                    }

                    window.wallet.setupCallbacks = () => {
                        window.doAuth.state = {}
                        if (window.document.readyState === "complete") {
                            window.wallet.setupCallbacksDo()
                        } else {
                            window.onload = window.wallet.setupCallbacksDo
                        }
                    }

                    main = async () => {
                        rcred = await doAuth.api.tofu(doAuth.server + doAuth.tofuPath)
                        console.log(rcred)
                        console.log(util.prettyPrint(rcred))
                        console.log(doAuth.credential.prooflessJSON(rcred))
                        console.log("Verifying...")
                        console.log(doAuth.credential.verify64(rcred, rcred.credentialSubject.me))
                        wallet.setupCallbacks()
                    }

                    main()
                }
            }
        </script>
        <script src="js/sodium.js" async></script>
        <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script>
    <h1>credential wallet demo</h1>
    <div>
        The purpose of this wallet demo is <strong>not</strong> to demonstrate how <strong>secure</strong> wallets are meant to be implemented, but rather show all the functions of doauth.
    </div>
    <div class="credential">
        <h2>credential signing</h2>
        <ul>
            <li>First, go through the steps listed in <strong>key management</strong> section</li>
            <li>Now you can make pre-defined credentials or even paste credential subject into textarea below and get self-signed credential as the result</li>
        </ul>
        <div class="">
            <h3>register with doauth server</h3>
            <div class="input">

            </div>
        </div>
        <div class="txFromKeypairCredential">
            <h3>verifiable credential from JSON claim</h3>
            <p>
                Example of credentialSubject is <pre>{
  "did": "did:doma:e-EKnyELclmtF1wMP6y5Xf9UxSQ-8eZRtY_GWrl0GqE=",
  "nickname": "liberated"
}</pre>
            </p>
            <div class="input">
                <textarea rows="24" cols="80" class="claim"></textarea><br />
                <input type="submit" value="make a signed credential" />
            </div>
            <pre class="output"></pre>
        </div>
    </div>
    <div class="crypto">
        <h2>key management</h2>
        <ul>
            <li>First, generate or regenerate main key, it will store its bytes in memory of this browser tab.</li>
            <li>Second, derive signing keypair from in-memory main key, it will put keypair into the.</li>
        </ul>
        <div class="mainKeyInit">
            <h3>initial generation</h3>
            <p>Enter your securely-stored in your password manager password for javascript to generate a keypair along with public slip.</p>
            <p>Make sure to not lose slip. It's not secret, so you can publish it anywhere.</p>
            <p>By default, slip shall be stored in localStorage, but don't rely on it.</p>
            <!-- TEST for setupCallbacksDo. Uncomment to check that setupCallbacksDo crashes on init.
            <div class="input">
            </div>
            -->
            <div class="input">
                <input class="password" type="password" placeholder="secure password" />
                <input type="submit" value="generate keypair in this browser tab's sandbox and STORE slip IN localStorage" />
            </div>
            <pre class="output"></pre>
        </div>
        <div class="withLocalStorageMainKeyReproduce">
            <h3>key regeneration from a password and a slip, stored in localStorage</h3>
            <div class="input">
                <input class="password" type="password" placeholder="secure password" />
                <input type="submit" value="GET slip FROM localStorage and regenerate keypair in this browser tab's sandbox" />
            </div>
            <pre class="output"></pre>
        </div>
        <div class="mainKeyReproduce">
            <h3>key regeneration from a password and a pasted slip</h3>
            <div class="input">
                <input class="password" type="password" placeholder="secure password" /><br />
                <label>slip JSON</label><textarea rows="6" cols="36" class="slip"></textarea><br />
                <input type="submit" value="regenerate keypair in this browser tab's sandbox" />
            </div>
            <pre class="output"></pre>
        </div>
        <div class="deriveSigningKeypair">
            <h3>signing key derivation</h3>
            <div class="input">
                <input class="index" type="number" min="1" max="100" value="1" />
                <input type="submit" value="generate signing keypair with given index from in-memory main key (doAuth.state.mkey)" />
            </div>
            <pre class="output">
            </pre>
        </div>
    </div>
    </body>
</html>
